<% c++ #include <content.h> %>
<% skin mitpgpskin %>
<% view stats uses peaks::pks::content::stats %>
<% template render() %>
<html>
<head>
    <link rel="stylesheet" href="/css/style.css"/>
    <script type="text/javascript" src="/js/chart.min.js"></script>
    <script type="text/javascript" src="/js/json2.js"></script>
    <script type="text/javascript" src="/js/jsonrpc.js"></script>
    <script type="text/javascript" src="/js/main.js"></script>
</head>
<body onload="main();">
<div id="tabs">
  <button onclick="switchTab(event, 'ptree')">Ptree</button>
  <button onclick="switchTab(event, 'certificates')">Certificates</button>
  <button onclick="switchTab(event, 'userattributes')">Userattributes</button>
  <button onclick="switchTab(event, 'pubkey')">Pubkey</button>
</div>
<div class="stats">
    <div class="main">
    </div>
    <div class="ptree" style="display: none">
        <h1>Stats</h1>
          <h2>Ptree</h2>
          <!-- pippozzo -->
          <p>The ptree is basically a tree in which the arity is decided by the bitquan-
          tum parameter. The structure of the tree has to be for two servers to syn-
          chronize properly. A tree is a widely used structure in computing because
          they allow faster insert, search and retrieval compared to linked lists as long
          as the tree is balanced.
          If the tree is unbalanced (up to the point that become totally flat) part
          of its effectiveness is lost.
          This analysis try to point out the current state of the ptree, by looking
          at its height, balance, leaf distribution and elements per leaf node so that
          we know if it is effective as it is designed to be.

          A tree is balanced only if for every intermediate node
          of the tree the following properties hold:
          • The left and right subtree heights differ by at most one.
          • The left subtree is balanced
          • The right subtree is balanced
          Some tree structure implementation offer auto-balancing properties, but
          this is not the case for the ptree implementation, which has been designed
          with the idea that hashsum of certificates would be equally distributed, since
          the output string of an hash function can be considered “casual”. So with a
          clever implementation that would divide hashsums between nodes based on
          the corresponding numerical value, the tree should be always balanced.

          </p>
          <div id="ptree-table-container">
             <table id="ptree-table">
             <tr>
                 <th>Field</th>
                 <th>Value</th>
             </tr>
            </table>
        </div>
        <div class="ptree-chart1">
        <!-- node numbers per level -->
            <canvas id="ptree-chart1">Canvas not working :(</canvas>
    
        </div>
        <div class="ptree-chart2">
        <!-- element per node -->
            <canvas id="ptree-chart2">Canvas not working :(</canvas>
        </div>
    </div>
    <div class="certificates" style="display: none">
        <div class="cert-chart-ua">
        <!-- certificates size with/without ua -->
            <canvas id="cert-chart-ua">Canvas not working :(</canvas>
        </div>
        <div class="cert-chart-noua">
        <!-- certificates size with/without ua -->
            <canvas id="cert-chart-noua">Canvas not working :(</canvas>
        </div>
    </div>
    <div class="userattributes" style="display: none">
        <div class="userattributes-chart-image">
        <!-- certificates size with/without ua -->
            <canvas id="userattributes-chart-image">Canvas not working :(</canvas>
        </div>
        <div class="userattributes-chart-other">
        <!-- certificates size with/without ua -->
            <canvas id="userattributes-chart-other">Canvas not working :(</canvas>
        </div>
        <div class="userattributes-pie">
        <!-- certificates size with/without ua -->
            <canvas id="userattributes-pie">Canvas not working :(</canvas>
        </div>
    </div>
    <div class="pubkey" style="display: none">
        <p>In this section we analyze the public keys loaded in peaks database. The
        grand total of public keys is 10446761, divided as shown:
        </p>
        <div class="pubkey-pie">
        <!-- pubkeys distribution pie -->
            <canvas id="pubkey-pie">Canvas not working :(</canvas>
        </div>
        <p>
        The following chart will provide a 20 year long view of the evolution of
        the algorithms used for the generation of public keys.
        </p>
        <div class="pubkey-stacked">
        <!-- pubkey year/algorithm distribution chart -->
            <canvas id="pubkey-stacked">Canvas not working :(</canvas>
        </div>
        <p>
        DSA and Elgamal were more prevalent before 2003-04 when RSA keys
        started taking place quickly, maybe due to RSA being adopted as the default
        choice by GPG, due to being, at the time, the way to overcome old DSA 1024-
        bit limit, and 160-bit signature limit, and by SSH key generator utility [8].
        While Elliptic Curve being considered the future of public key algorithms is
        still considerable in its infancy because its usages are rare: less than 1% of
        keys are generated by EC.
        </p>

        <h3>RSA</h3>
        <p>
        RSA public keys are the majority of the set. They account for almost
        50% of public keys.
        As of today standards keys created with a bits size of less than 2048 are
        not considered secure [2]. Until 1980s, key of 512 bits were recommended as
        sufficient security standard. Since many embedded devices did not provide
        enough processing power to have an efficient generation of larger keys even
        330 bits keys were used in the early 1980s. Academic successes in breaking
        those keys, led to a change in recommended key size, which would increase
        to 1024 during the 1990s.
        The chart represent the numbers of keys with the corresponding n pa-
        rameter found. It is easy to see that since 2013 there was a shift to adopt
        more robust key sizes, and it is a positive news. However during the very
        last year is possible to see also a spike in the creation of weak keys.
        </p>
        <div class="pubkey-rsa">
        <!-- In depth RSA distribution per year -->
            <canvas id="pubkey-rsa">Canvas not working :(</canvas>
        </div>
        
        <h3>Elgamal</h3>
        <p>Elgamal public keys are almost the 26% of the set.</p>
        <div class="pubkey-elgamal">
        <!-- In depth Elgamal distribution per year -->
            <canvas id="pubkey-elgamal">Canvas not working :(</canvas>
        </div>
        <p>
        A 1024 bits length for p is no more secure and should not be used. Until
        2020/2030 a length of 2048 bits can still be considered secure, but after 2030
        should be used p with a length of at least 3072. The chart show that the
        trend in using Elgamal is declining
        </p>

        <h3>DSA</h3>
        <p>
        DSA public keys are almost the 25% of the set.
        </p>
        <div class="pubkey-dsa">
        <!-- In depth DSA distribution per year -->
            <canvas id="pubkey-dsa">Canvas not working :(</canvas>
        </div>
        <p>
        This graph is similar to the Elgamal one for the same reason. In the chart
        is presented a view of the two parameters of DSA, q and p which present
        the same trend. p is considered no longer secure with a length of 1024 bits
        or less, 2048 bits are needed to achieve a recommended level of security.
        </p>

        <h3>Elliptic Curve</h3>
        <p>Elliptic Curve keys are the least used, only 0.13% of the set.</p>
        <div class="pubkey-ec">
        <!-- In depth Elliptic Curve distribution per year -->
            <canvas id="pubkey-ec">Canvas not working :(</canvas>
        </div>
        <p> The elliptic curve algorithms in OpenPGP use some fixed curves, thus
        there is no need for plotting and check their size.</p>

    </div>
    </div>
</div>
</body>
</html>
<% end template %>
<% end view %>
<% end skin %>

